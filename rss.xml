<?xml version='1.0' encoding='UTF-8' ?>
<rss version='2.0'>
<channel>
  <title>Zuguang Gu's blog</title>
  <link>http://jokergoo.github.io/blog.html</link>
  <description>Zuguang Gu's blog</description>

<item>
<title>Circular visualization of DMRs from tagmentation-based WGBS</title>
<link>http://jokergoo.github.io/blog/html/179f20c97f68d2a32beaf89d6a925963.html</link>
<pubDate>Fri, 25 Mar 2016 11:38:22 CET</pubDate>
<description>


&lt;p&gt;&lt;a href="http://www.nature.com/nprot/journal/v8/n10/full/nprot.2013.118.html"&gt;Tagmentation-based whole-genome bisulfite sequencing&lt;/a&gt; 
(T-WGBS) is a technology which can examine only a minor fraction of methylome of interest.
Circular plot can be used to &lt;a href="http://jokergoo.github.io/circlize/example/railfallplot.html"&gt;visualize genome-wide distribution of differentially methylation
regions (DMRs)&lt;/a&gt;. 
In this post, we demonstrate how to visualize DMRs which are detected from T-WGBS data in a circular plot by &lt;strong&gt;circlize&lt;/strong&gt; package.&lt;/p&gt;

&lt;p&gt;In &lt;a href="../../data/tagments_WGBS_DMR.RData"&gt;&lt;code&gt;tagments_WGBS_DMR.RData&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;tagments&lt;/code&gt; contains regions which are sequenced, 
&lt;code&gt;DMR1&lt;/code&gt; and &lt;code&gt;DMR2&lt;/code&gt; contain DMRs for two patients detectd in tagment regions. Correspondance between tagment regions
and DMRs can be checked by row names of &lt;code&gt;tagments&lt;/code&gt; and &lt;code&gt;tagment&lt;/code&gt; column in &lt;code&gt;DMR1&lt;/code&gt; or &lt;code&gt;DMR2&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;load(&amp;quot;../data/tagments_WGBS_DMR.RData&amp;quot;)
tagments[1:2, ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##                         chr    start      end
## chr1-44876009-45016546 chr1 44876009 45016546
## chr1-90460304-90761641 chr1 90460304 90761641
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="r"&gt;DMR1[1:2, ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    chr    start      end   methDiff                tagment
## 1 chr1 44894352 44894643 -0.2812889 chr1-44876009-45016546
## 2 chr1 44902069 44902966 -0.3331170 chr1-44876009-45016546
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="r"&gt;DMR2[1:2, ]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;##    chr    start      end   methDiff                tagment
## 1 chr2 64979958 64980308 -0.2151918 chr2-64897317-65173964
## 2 chr2 65038093 65039051 -0.2082847 chr2-64897317-65173964
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chromosomes (e.g. &lt;code&gt;chr1&lt;/code&gt;, &lt;code&gt;chr2&lt;/code&gt;) and tagments (e.g. &lt;code&gt;chr1-44876009-45016546&lt;/code&gt;, &lt;code&gt;chr1-90460304-90761641&lt;/code&gt;)
are actually different types of categories and &lt;strong&gt;circlize&lt;/strong&gt; can only deal with one type at a time.
In order to merge chromosomes and tagment regions into one same plot, the strategy is to create two independent
circular plot but overlay the second one directly to the first one by specifying &lt;code&gt;par(new = TRUE)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;First we draw the ideograms as well as the chromosome names and we call it &amp;#39;the first circular plot&amp;#39;.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;library(circlize)

circos.par(gap.degree = 2, start.degree = 90)
circos.initializeWithIdeogram(chromosome.index = paste0(&amp;quot;chr&amp;quot;, 1:22), plotType = c(&amp;quot;ideogram&amp;quot;, &amp;quot;labels&amp;quot;),
    ideogram.height = 0.03)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Please see the figure in the original post.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;To make the correspondance between two circular plots, we need mapping of a same genomic position
between two circular plots. Here the key solution is the polar coordinate system because all circular
plot created by &lt;strong&gt;circlize&lt;/strong&gt; are in a same polar coordinate system. With using &lt;code&gt;circlize()&lt;/code&gt; function, we can transform
genomic positions in one circular plot into polar coordinates and we can apply &lt;code&gt;reverse.circlize()&lt;/code&gt; to get 
the new genomic positions in the second circualr plot.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;# calculate position of each tagment measured in the polar coordinate system
for(i in seq_len(nrow(tagments))) {
    tagments[i, &amp;quot;theta1&amp;quot;] = circlize(tagments[i, 2], 1, sector.index = tagments[i, 1])[1, 1]
    tagments[i, &amp;quot;theta2&amp;quot;] = circlize(tagments[i, 3], 1, sector.index = tagments[i, 1])[1, 1]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the second circular plot which visualizes DMRs will be put inside the ideograms, we need to know
the radius which inside the ideogram. Since the ideogram in the first circular plot is the last track, we can
use &lt;code&gt;circlize:::get_most_inside_radius()&lt;/code&gt; to get the position.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;r = circlize:::get_most_inside_radius()
circos.clear()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we make the second circular plot which visualizes DMRs. Here &lt;code&gt;par(new = TRUE)&lt;/code&gt; is set to directly overlay
to the first plot. &lt;/p&gt;

&lt;p&gt;in &lt;code&gt;circos.par()&lt;/code&gt;, &lt;code&gt;start.degree&lt;/code&gt; can be adjusted to rotate the second circular plot to make better correspondance
between two circular plots.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;chr_bg_color&lt;/code&gt; is defined here to enhance discrimination of different chromosomes.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;par(new = TRUE)

set.seed(123)
chr_bg_color = rand_color(22, transparency = 0.8)
names(chr_bg_color) = paste0(&amp;quot;chr&amp;quot;, 1:22)

circos.par(cell.padding = c(0.02, 0, 0.02, 0), gap.degree = c(rep(1, nrow(tagments)-1), 10), 
    start.degree = 75, points.overflow.warning = FALSE)
circos.initialize(factors = factor(rownames(tagments), levels = rownames(tagments)), 
    xlim = as.matrix(tagments[, 2:3]))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first track of the second circular plot, we need to draw kind of connections between two circular
plots. Since we know the coordinates of tagment regions in the polar coordinate system, here we use 
&lt;code&gt;reverse.circlize()&lt;/code&gt; to transform back to the corresponding genomic positions (or coordinate in the data coordinate system).&lt;/p&gt;

&lt;p&gt;Since the second plot is drawn inside the ideograms, &lt;code&gt;r&lt;/code&gt; is set as the outter margin of the second plot.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;circos.track(ylim = c(0, 1), panel.fun = function(x, y) {

    si = get.cell.meta.data(&amp;quot;sector.index&amp;quot;)
    chr = gsub(&amp;quot;^(chr.*?)-.*$&amp;quot;, &amp;quot;\\1&amp;quot;, si)
    theta1 = tagments[si, &amp;quot;theta1&amp;quot;]
    theta2 = tagments[si, &amp;quot;theta2&amp;quot;]

    xlim = get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;)
    ylim = get.cell.meta.data(&amp;quot;cell.ylim&amp;quot;)

    cell.top.radius = get.cell.meta.data(&amp;quot;cell.top.radius&amp;quot;)

    # map from polar coordinate system to data coordinate system
    df = reverse.circlize(c(theta1, theta2), c(cell.top.radius, cell.top.radius))

    x21 = df[1, 1]
    x22 = df[2, 1]
    y21 = df[1, 2]
    y22 = df[2, 2]
    x11 = xlim[1]
    x12 = xlim[2]
    y11 = ylim[1]
    y12 = ylim[1]
    circos.polygon(c(x11, x11, x21, x21, x22, x22, x12, x12, x11),
                   c(y11, (y21 - y11)/3, (y21 - y11)/3*2, y21, y22, (y22 - y12)/3*2, (y22 - y12)/3, y12, y11), 
                   col = chr_bg_color[chr])

}, track.margin = c(0, 1 - r), cell.padding = c(0, 0, 0, 0), bg.border = NA, track.height = 0.1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Please see the figure in the original post.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Now we add DMR tracks. In each cell (plotting region), we added the background with colors,
reference lines and points.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;max_abs = max(abs(c(DMR1$methDiff, DMR2$methDiff)))
max_abs = ceiling(max_abs*10)/10
circos.track(ylim = c(-max_abs, max_abs), panel.fun = function(x, y) {
    si = get.cell.meta.data(&amp;quot;sector.index&amp;quot;)
    chr = gsub(&amp;quot;^(chr\\d+).*$&amp;quot;, &amp;quot;\\1&amp;quot;, si)
    xlim = get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;)
    ylim = get.cell.meta.data(&amp;quot;cell.ylim&amp;quot;)

    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = chr_bg_color[[chr]])
    for(h in seq(-max_abs, max_abs, by = 0.3)) {
        circos.lines(xlim, c(h, h), lty = 3, col = &amp;quot;#AAAAAA&amp;quot;)
    }

    circos.lines(xlim, c(0, 0), lty = 3, col = &amp;quot;#888888&amp;quot;)

    subset = DMR1[DMR1$tagment == si, , drop = FALSE]
    if(nrow(subset) &amp;gt; 0) {
        circos.points((subset[[2]] + subset[[3]])/2, subset$methDiff, 
            col = ifelse(subset$methDiff &amp;gt; 0, &amp;quot;#E41A1C&amp;quot;, &amp;quot;#377EB8&amp;quot;), pch = 16, cex = 0.5)
    }

}, bg.border = 1, track.height = 0.15)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also we add y-axis and labels on the left of the first tagment.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;first_sector = get.all.sector.index()[1]
circos.yaxis(side = &amp;quot;left&amp;quot;, at = seq(-0.6, 0.6, by = 0.3), sector.index = first_sector,
    labels.cex = 0.4)
xlim = get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;, sector.index = first_sector)
ylim = get.cell.meta.data(&amp;quot;cell.ylim&amp;quot;, sector.index = first_sector)
circos.text(xlim[1], mean(ylim), &amp;quot;d1&amp;quot;, facing = &amp;quot;clockwise&amp;quot;, niceFacing = TRUE, cex = 0.8, 
    adj = c(0.5, degree(6)), sector.index = first_sector)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Please see the figure in the original post.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Add the DMRs for the second patient.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;circos.track(ylim = c(-max_abs, max_abs), panel.fun = function(x, y) {
    si = get.cell.meta.data(&amp;quot;sector.index&amp;quot;)
    chr = gsub(&amp;quot;^(chr\\d+).*$&amp;quot;, &amp;quot;\\1&amp;quot;, si)
    xlim = get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;)
    ylim = get.cell.meta.data(&amp;quot;cell.ylim&amp;quot;)
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = chr_bg_color[[chr]])
    for(h in seq(-max_abs, max_abs, by = 0.3)) {
        circos.lines(xlim, c(h, h), lty = 3, col = &amp;quot;#AAAAAA&amp;quot;)
    }
    circos.lines(xlim, c(0, 0), lty = 3, col = &amp;quot;#888888&amp;quot;)
    subset = DMR2[DMR2$tagment == si, , drop = FALSE]
    if(nrow(subset) &amp;gt; 0) {
        circos.points((subset[[2]] + subset[[3]])/2, subset$methDiff, 
            col = ifelse(subset$methDiff &amp;gt; 0, &amp;quot;#E41A1C&amp;quot;, &amp;quot;#377EB8&amp;quot;), pch = 16, cex = 0.5)
    }
}, bg.border = 1, track.height = 0.15)
circos.yaxis(side = &amp;quot;left&amp;quot;, at = seq(-0.6, 0.6, by = 0.3), sector.index = first_sector,
    labels.cex = 0.4)
xlim = get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;, sector.index = first_sector)
ylim = get.cell.meta.data(&amp;quot;cell.ylim&amp;quot;, sector.index = first_sector)
circos.text(xlim[1], mean(ylim), &amp;quot;d2&amp;quot;, facing = &amp;quot;clockwise&amp;quot;, niceFacing = TRUE, cex = 0.8, 
    adj = c(0.5, degree(6)), sector.index = first_sector)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the most inside track, we explicitely show the color of chromosomes to make it easier to correspond
between target regions to chromosomes.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;circos.track(ylim = c(0, 1), panel.fun = function(x, y) {
    cate = get.cell.meta.data(&amp;quot;sector.index&amp;quot;)
    chr = gsub(&amp;quot;^(chr\\d+).*$&amp;quot;, &amp;quot;\\1&amp;quot;, cate)
    xlim = get.cell.meta.data(&amp;quot;cell.xlim&amp;quot;)
    ylim = get.cell.meta.data(&amp;quot;cell.ylim&amp;quot;)
    circos.rect(xlim[1], ylim[1], xlim[2], ylim[2], col = gsub(&amp;quot;\\d\\d$&amp;quot;, &amp;quot;&amp;quot;, chr_bg_color[[chr]]))
}, track.height = 0.02, cell.padding = c(0, 0, 0, 0))

circos.clear()

legend(&amp;quot;center&amp;quot;, pch = 16, legend = c(&amp;quot;Hyper-DMR&amp;quot;, &amp;quot;Hypo-DMR&amp;quot;), col = c(&amp;quot;#E41A1C&amp;quot;, &amp;quot;#377EB8&amp;quot;))

par(new = FALSE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Please see the figure in the original post.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Session info&lt;/h2&gt;

&lt;pre&gt;&lt;code class="r"&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## R version 3.2.3 (2015-12-10)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.11.3 (El Capitan)
## 
## locale:
## [1] C/en_US.UTF-8/C/C/C/C
## 
## attached base packages:
## [1] grid      methods   stats     graphics  grDevices utils     datasets 
## [8] base     
## 
## other attached packages:
## [1] circlize_0.3.5       ComplexHeatmap_1.9.3 digest_0.6.9        
## [4] htmltools_0.3        GetoptLong_0.1.1     markdown_0.7.7      
## [7] knitr_1.12.3        
## 
## loaded via a namespace (and not attached):
##  [1] dendextend_1.1.8    mime_0.4            formatR_1.3        
##  [4] magrittr_1.5        evaluate_0.8.3      stringi_1.0-1      
##  [7] GlobalOptions_0.0.9 whisker_0.3-2       RColorBrewer_1.1-2 
## [10] rjson_0.2.15        tools_3.2.3         stringr_1.0.0      
## [13] colorspace_1.2-6    shape_1.4.2
&lt;/code&gt;&lt;/pre&gt;


</description>
</item>

<item>
<title>Visualize mean signals in row clusters by ComplexHeatmap</title>
<link>http://jokergoo.github.io/blog/html/91ca5112777739c320613e649b48671d.html</link>
<pubDate>Fri, 25 Mar 2016 11:38:22 CET</pubDate>
<description>


&lt;p&gt;In this post, we will demonstrate how to visualize mean signals in row clusters by &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; pacakge.&lt;/p&gt;

&lt;p&gt;First we load the packages and generate the random matrix.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;library(ComplexHeatmap)
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## Loading required package: grid
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class="r"&gt;library(circlize)
library(RColorBrewer)

set.seed(123)

mat = cbind(rbind(matrix(rnorm(64, -1), 8), matrix(rnorm(64, 1), 8), matrix(rnorm(64, -1), 8)),
            rbind(matrix(rnorm(64, 1), 8), matrix(rnorm(64, -2), 8), matrix(rnorm(64, -1), 8)),
            rbind(matrix(rnorm(64, -0.5), 8), matrix(rnorm(64, -1), 8), matrix(rnorm(64, 1), 8)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The random matrix contains three distinct subgroups by rows and following is how it looks by means of heatmap.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;Heatmap(mat)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Please see the figure in the original post.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Next we are going to do little bit more to enhance the visual effect on the row clusters:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;split the heatmap by rows to separate row clusters.&lt;/li&gt;
&lt;li&gt;show and compare mean signals in row clusters. &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We apply k-means clustering on rows. Although you can specify it by &lt;code&gt;km&lt;/code&gt; in &lt;code&gt;Heatmap()&lt;/code&gt; function, since
the partitioning information wil be used in several places, we calculate it in the first place.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;km = 3
colors = brewer.pal(km, &amp;quot;Set1&amp;quot;)
partition = kmeans(dist(mat), centers = km)$cluster
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will put the mean signals in row clusters as a column annotation put on top of the heatmap.
This can be done by constructing a self-defined annotation function. The only input of this function
is &lt;code&gt;index&lt;/code&gt; which is the index of columns that will be automatically adjusted by column clustering or column reordering.&lt;/p&gt;

&lt;p&gt;In following code, the basic logic is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;calculate mean value in different row cluster,&lt;/li&gt;
&lt;li&gt;push a viewport to put graphics,&lt;/li&gt;
&lt;li&gt;add polygons which show the mean signals,&lt;/li&gt;
&lt;li&gt;add y-axis.&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class="r"&gt;anno_col_mean = function(index) {
    col_means = lapply(1:km, function(i) colMeans(mat[partition == i, index]))
    n = length(index)
    rg = range(unlist(col_means))
    pushViewport(viewport(xscale = c(0.5, n + 0.5), yscale = rg))
    grid.rect(gp = gpar(fill = &amp;quot;transparent&amp;quot;))
    for(i in seq_along(col_means)) {
        grid.polygon(c(1:n, n:1), c(col_means[[i]], rep(rg[1], n)), 
            gp = gpar(fill = paste0(colors[i], &amp;quot;80&amp;quot;), col = NA), default.units = &amp;quot;native&amp;quot;)
    }
    grid.yaxis(gp = gpar(fontsize = 8))
    upViewport()
}

ha = HeatmapAnnotation(col_mean = anno_col_mean)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can put everything to make the new heatmap. In the heatmap, we specified &lt;code&gt;split = partition&lt;/code&gt; to
split the heatmap by k-means partition which has already be calculated. To make the correspondance
between signal lines and row clusters, we add a color bar on the right of the main heatmap.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;Heatmap(mat, name = &amp;quot;foo&amp;quot;, column_dend_side = &amp;quot;bottom&amp;quot;, top_annotation = ha, 
    top_annotation_height = unit(2, &amp;quot;cm&amp;quot;), split = partition, show_row_names = FALSE) +
Heatmap(partition, col = structure(colors, names = as.character(1:km)), show_row_names = FALSE, 
    show_heatmap_legend = FALSE, name = &amp;quot;&amp;quot;)

decorate_annotation(&amp;quot;col_mean&amp;quot;, {grid.text(&amp;quot;mean\nsignal&amp;quot;, unit(-10, &amp;quot;mm&amp;quot;), rot = 90, just = &amp;quot;bottom&amp;quot;)})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Please see the figure in the original post.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Session Info&lt;/h2&gt;

&lt;pre&gt;&lt;code class="r"&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## R version 3.2.3 (2015-12-10)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.11.3 (El Capitan)
## 
## locale:
## [1] C/en_US.UTF-8/C/C/C/C
## 
## attached base packages:
## [1] grid      methods   stats     graphics  grDevices utils     datasets 
## [8] base     
## 
## other attached packages:
## [1] RColorBrewer_1.1-2   circlize_0.3.5       ComplexHeatmap_1.9.3
## [4] digest_0.6.9         htmltools_0.3        GetoptLong_0.1.1    
## [7] markdown_0.7.7       knitr_1.12.3        
## 
## loaded via a namespace (and not attached):
##  [1] dendextend_1.1.8    magrittr_1.5        evaluate_0.8.3     
##  [4] stringi_1.0-1       GlobalOptions_0.0.9 whisker_0.3-2      
##  [7] rjson_0.2.15        tools_3.2.3         stringr_1.0.0      
## [10] colorspace_1.2-6    shape_1.4.2
&lt;/code&gt;&lt;/pre&gt;


</description>
</item>

<item>
<title>Merge heatmap and annotation legends into a same column</title>
<link>http://jokergoo.github.io/blog/html/ed8209ec0c73bd19d66a99054783b89f.html</link>
<pubDate>Sat, 19 Mar 2016 17:09:33 CET</pubDate>
<description>


&lt;p&gt;In &lt;strong&gt;ComplexHeatmap&lt;/strong&gt; package, legends for heatmap and annotations are differently treated
and they will be put in different places. However, if there are not too many heatmaps and annotations,
separating these two types of legends will be kind of waste of spaces.&lt;/p&gt;

&lt;p&gt;In &lt;code&gt;draw()&lt;/code&gt; method of &lt;code&gt;HeatmapList&lt;/code&gt; class, there is an option &lt;code&gt;heatmap_legend_list&lt;/code&gt; (or &lt;code&gt;annotation_legend_list&lt;/code&gt;) which accepts
additional self-defined legends (in a form of &lt;code&gt;grob&lt;/code&gt; objects). Thus, one strategy to merge
heatmap legends and annotation legends is to extract the legends first and suppress plotting legends, 
later we construct a list of legends and send to &lt;code&gt;heatmap_legend_list&lt;/code&gt; argument.&lt;/p&gt;

&lt;p&gt;In following example, there is only one heatmap and two simple column annotations.
When constructing column annotaiton &lt;code&gt;ha&lt;/code&gt;, &lt;code&gt;show_legend&lt;/code&gt; is set to &lt;code&gt;FALSE&lt;/code&gt; to suppress annotation legends.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;library(ComplexHeatmap)
library(circlize)
df = data.frame(type = c(rep(&amp;quot;a&amp;quot;, 5), rep(&amp;quot;b&amp;quot;, 5)),
                age = sample(1:20, 10))

ha = HeatmapAnnotation(df = df,
    col = list(type = c(&amp;quot;a&amp;quot; = &amp;quot;red&amp;quot;, &amp;quot;b&amp;quot; = &amp;quot;blue&amp;quot;),
               age = colorRamp2(c(0, 20), c(&amp;quot;white&amp;quot;, &amp;quot;red&amp;quot;))),
    show_legend = FALSE
)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Color mapping information is stored in &lt;code&gt;ha&lt;/code&gt; and we can extract legends from &lt;code&gt;ha&lt;/code&gt; object.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;anno_legend_list = lapply(ha@anno_list[c(&amp;quot;type&amp;quot;, &amp;quot;age&amp;quot;)], 
    function(anno) color_mapping_legend(anno@color_mapping, plot = FALSE))
anno_legend_list
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## $type
## frame[GRID.frame.4] 
## 
## $age
## frame[GRID.frame.17]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similar, &lt;code&gt;show_heatmap_legend&lt;/code&gt; is set to &lt;code&gt;FALSE&lt;/code&gt; when creating &lt;code&gt;ht&lt;/code&gt; and legend object is extracted afterwards.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;mat = matrix(rnorm(80, 2), 8, 10)
ht = Heatmap(mat, name = &amp;quot;ht&amp;quot;, top_annotation = ha, show_heatmap_legend = FALSE)
heatmap_legend = color_mapping_legend(ht@matrix_color_mapping, plot = FALSE)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;code&gt;draw()&lt;/code&gt; is called explicitely and a list of both heatmap legend and annotation legends are sent to
&lt;code&gt;heatmap_legend_list&lt;/code&gt; argument.&lt;/p&gt;

&lt;pre&gt;&lt;code class="r"&gt;draw(ht, heatmap_legend_list = c(anno_legend_list, list(heatmap_legend)))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Please see the figure in the original post.&lt;/strong&gt;&lt;/p&gt;

&lt;h2&gt;Session Info&lt;/h2&gt;

&lt;pre&gt;&lt;code class="r"&gt;sessionInfo()
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code&gt;## R version 3.2.3 (2015-12-10)
## Platform: x86_64-apple-darwin13.4.0 (64-bit)
## Running under: OS X 10.11.3 (El Capitan)
## 
## locale:
## [1] C/en_US.UTF-8/C/C/C/C
## 
## attached base packages:
## [1] grid      methods   stats     graphics  grDevices utils     datasets 
## [8] base     
## 
## other attached packages:
## [1] circlize_0.3.5       ComplexHeatmap_1.9.3 digest_0.6.9        
## [4] htmltools_0.3        GetoptLong_0.1.1     markdown_0.7.7      
## [7] knitr_1.12.3        
## 
## loaded via a namespace (and not attached):
##  [1] dendextend_1.1.8    formatR_1.3         magrittr_1.5       
##  [4] evaluate_0.8.3      stringi_1.0-1       GlobalOptions_0.0.9
##  [7] whisker_0.3-2       RColorBrewer_1.1-2  rjson_0.2.15       
## [10] tools_3.2.3         stringr_1.0.0       colorspace_1.2-6   
## [13] shape_1.4.2
&lt;/code&gt;&lt;/pre&gt;


</description>
</item>

<item>
<title>Build a static website and blog by knitr and rmarkdown</title>
<link>http://jokergoo.github.io/blog/html/f085f205491c97284f4c5145c45012b1.html</link>
<pubDate>Mon, 14 Mar 2016 17:43:13 CET</pubDate>
<description>


&lt;p&gt;There is already very nice solutions to build a static website and blog
based on &lt;a href="https://help.github.com/articles/using-jekyll-with-pages/"&gt;Jekyll&lt;/a&gt; and host on &lt;a href="http://github.com"&gt;GitHub&lt;/a&gt;.
However, I still have problems to make a real functional website by learning those online tutorials. Actually
it is not that difficult to write my own scripts to generate static HTML pages.
Also it is easy to support &lt;strong&gt;knitr&lt;/strong&gt; package to automatically generate a HTML document with
executing R code on the fly.&lt;/p&gt;

&lt;p&gt;Take my website for example, there are &lt;code&gt;index.html&lt;/code&gt;, &lt;code&gt;software.html&lt;/code&gt;, &lt;code&gt;publications.html&lt;/code&gt; which
are converted from &lt;a href="https://raw.githubusercontent.com/jokergoo/jokergoo.github.io/master/index.md"&gt;&lt;code&gt;index.md&lt;/code&gt;&lt;/a&gt;, 
&lt;a href="https://raw.githubusercontent.com/jokergoo/jokergoo.github.io/master/software.md"&gt;&lt;code&gt;software.md&lt;/code&gt;&lt;/a&gt;, 
&lt;a href="https://raw.githubusercontent.com/jokergoo/jokergoo.github.io/master/publications.md"&gt;&lt;code&gt;publications.md&lt;/code&gt;&lt;/a&gt; respectively. 
&lt;a href="https://github.com/jokergoo/jokergoo.github.io/blob/master/generate_website.R"&gt;A general script&lt;/a&gt; takes
care of the common HTML head and foot for each HTML document, reads the &lt;code&gt;.md&lt;/code&gt; files and convert to the HTML fragment.&lt;/p&gt;

&lt;p&gt;For the blog part, there is a sub-folder called &lt;code&gt;blog/&lt;/code&gt; and posts in &lt;code&gt;.md&lt;/code&gt; or &lt;code&gt;.Rmd&lt;/code&gt; format are put in.
If the file name of the post ends with &lt;code&gt;.Rmd&lt;/code&gt;, &lt;code&gt;knit()&lt;/code&gt; is first called and converts into HTML fragment by &lt;code&gt;markdownToHTML()&lt;/code&gt;
afterwards, while if the file name of the post ends with &lt;code&gt;.md&lt;/code&gt;, &lt;code&gt;markdownToHTML()&lt;/code&gt; is simply called to convert
to HTML fragment.&lt;/p&gt;

&lt;p&gt;There is a tiny &amp;ldquo;database&amp;rdquo; (&lt;code&gt;post_info&lt;/code&gt;) which records some basic information for a post, e.g. create time, last
modified time so that post without changes does not need to be re-generated. &lt;/p&gt;

&lt;p&gt;&lt;a href="https://en.wikipedia.org/wiki/Inode"&gt;Inode&lt;/a&gt; is used as the unique identifier of files. The drawback is 
the HTML pages can only be generated in a same computer.&lt;/p&gt;

&lt;p&gt;After all posts are generated, title for each post is extracted as well as the creating time,
which will be used to generate &lt;code&gt;blog.html&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If comments system is to be supported, after the HTML generation of each post, the Javascript fragment of &lt;a href="https://disqus.com/home/"&gt;Disqus&lt;/a&gt;
can be inserted before &lt;code&gt;&amp;lt;/body&amp;gt;&lt;/code&gt;.&lt;/p&gt;


</description>
</item>


</channel>
</rss>

